<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mandelbrot Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
      body {
        background: #050505;
        color: #eee;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
      }
      #toolbar {
        background: #1a1a1a;
        padding: 12px 25px;
        border-radius: 50px;
        margin-bottom: 15px;
        display: flex;
        gap: 15px;
        align-items: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
        border: 1px solid #333;
      }
      canvas {
        border-radius: 8px;
        cursor: crosshair;
        box-shadow: 0 0 40px rgba(0, 255, 204, 0.15);
        background: black;
        border: 1px solid #222;
      }
      .stat {
        font-family: monospace;
        font-size: 0.85em;
        color: #00ffcc;
        text-transform: uppercase;
      }
      input {
        background: #000;
        color: #00ffcc;
        border: 1px solid #444;
        border-radius: 20px;
        padding: 6px 15px;
        width: 340px;
        font-family: monospace;
        outline: none;
      }
      button {
        background: #222;
        color: white;
        border: 1px solid #444;
        padding: 8px 18px;
        border-radius: 20px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.8em;
      }
      button:hover {
        border-color: #00ffcc;
        color: #00ffcc;
      }
      #modeIndicator {
        font-size: 0.7em;
        padding: 3px 8px;
        border-radius: 10px;
        border: 1px solid currentColor;
        font-weight: bold;
      }
      .tourist {
        color: #4caf50;
      }
      .explorer {
        color: #ff3366;
        text-shadow: 0 0 5px #ff3366;
      }
      .instructions {
        margin-top: 15px;
        font-size: 0.85em;
        color: #888;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <button onclick="goBack()" id="backBtn" disabled>PREVIOUS</button>
      <button onclick="resetView()">RESET</button>
      <div style="display: flex; gap: 5px">
        <input
          list="locations"
          id="coordInput"
          placeholder="a + bi"
          onfocus="this.value = ''"
          onchange="this.blur()"
        />
        <datalist id="locations">
          <option value="-0.743643887 + 0.131825904i | Z: 5e4 | I: 1000">
            Seahorse Valley
          </option>
          <option value="-0.743644786 + 0.131825963i | Z: 1e14 | I: 5000">
            The Heart of the Spiral
          </option>
          <option value="-0.00164 + 0.82246i | Z: 1e3 | I: 800">
            The Dragon Tail
          </option>
        </datalist>
        <button onclick="jumpToCoord()">JUMP</button>
      </div>
      <div class="stat">Z: <span id="zoomLevel">1.0</span></div>
      <div id="modeIndicator" class="tourist">TOURIST</div>
      <button onclick="saveImage()" style="color: #4fa3ff">SAVE PNG</button>
    </div>

    <canvas id="fCanvas" width="900" height="600"></canvas>

    <div class="instructions">
      Click anywhere to zoom in at 5 times depth. Double click the input to get
      example spots.<br />
      You can Reset to get the fullset or recover your past images by .
    </div>

    <script>
      const canvas = document.getElementById("fCanvas");
      const ctx = canvas.getContext("2d");
      const zoomText = document.getElementById("zoomLevel");
      const modeInd = document.getElementById("modeIndicator");
      const backBtn = document.getElementById("backBtn");
      const coordInput = document.getElementById("coordInput");

      const initialState = { r: -0.5, i: 0, zoom: 3.0, maxIter: 150 };
      let state = { ...initialState };
      let history = [];

      function render() {
        const { width, height } = canvas;
        const imgData = ctx.createImageData(width, height);
        const isExplorer = state.zoom < 1e-12;

        modeInd.innerText = isExplorer ? "EXPLORER (STABILIZED)" : "TOURIST";
        modeInd.className = isExplorer ? "explorer" : "tourist";

        // 1. Reference Orbit
        let refR = new Float64Array(state.maxIter);
        let refI = new Float64Array(state.maxIter);
        let zr = state.r,
          zi = state.i,
          refEscaped = false;

        for (let n = 0; n < state.maxIter; n++) {
          refR[n] = zr;
          refI[n] = zi;
          let r2 = zr * zr,
            i2 = zi * zi;
          if (r2 + i2 > 4) {
            refEscaped = true;
            break;
          }
          zi = 2 * zr * zi + state.i;
          zr = r2 - i2 + state.r;
        }

        // 2. Symmetry Logic
        const isSymmetric = Math.abs(state.i) < (state.zoom / height) * 0.5;
        const maxY = isSymmetric ? Math.ceil(height / 2) : height;

        // 3. Render Loop
        for (let y = 0; y < maxY; y++) {
          for (let x = 0; x < width; x++) {
            let dx = (x - width / 2) * (state.zoom / width);
            let dy = (y - height / 2) * (state.zoom / width);
            let iter = 0;

            if (isExplorer && !refEscaped) {
              let dzR = 0,
                dzI = 0;
              while (iter < state.maxIter) {
                let zr_n = refR[iter],
                  zi_n = refI[iter];
                let tr =
                  2 * (zr_n * dzR - zi_n * dzI) + (dzR * dzR - dzI * dzI) + dx;
                let ti = 2 * (zr_n * dzI + zi_n * dzR) + 2 * dzR * dzI + dy;
                dzR = tr;
                dzI = ti;
                // RECONSTRUCTED ESCAPE CHECK
                if ((zr_n + dzR) ** 2 + (zi_n + dzI) ** 2 > 4) break;
                iter++;
              }
            } else {
              let cr = state.r + dx,
                ci = state.i + dy,
                zr_s = 0,
                zi_s = 0;
              while (iter < state.maxIter) {
                let r2 = zr_s * zr_s,
                  i2 = zi_s * zi_s;
                if (r2 + i2 > 4) break;
                zi_s = 2 * zr_s * zi_s + ci;
                zr_s = r2 - i2 + cr;
                iter++;
              }
            }

            let p = (y * width + x) * 4;
            let r = 0,
              g = 0,
              b = 0;
            if (iter < state.maxIter) {
              let s = iter * 0.15;
              r = Math.sin(s) * 127 + 128;
              g = Math.sin(s + 2.09) * 127 + 128;
              b = Math.sin(s + 4.18) * 127 + 128;
            }

            imgData.data[p] = r;
            imgData.data[p + 1] = g;
            imgData.data[p + 2] = b;
            imgData.data[p + 3] = 255;
            if (isSymmetric) {
              let p2 = ((height - 1 - y) * width + x) * 4;
              imgData.data[p2] = r;
              imgData.data[p2 + 1] = g;
              imgData.data[p2 + 2] = b;
              imgData.data[p2 + 3] = 255;
            }
          }
        }
        ctx.putImageData(imgData, 0, 0);

        if (document.activeElement !== coordInput) {
          coordInput.value = `${state.r.toPrecision(12)} ${state.i >= 0 ? "+" : "-"} ${Math.abs(state.i).toPrecision(12)}i`;
        }
        zoomText.innerText = (3.0 / state.zoom).toExponential(2);
        backBtn.disabled = history.length === 0;
      }

      function jumpToCoord() {
        const val = coordInput.value;
        const match = val.match(
          /([-+]?\d*\.?\d+(?:e[-+]?\d+)?)\s*([-+]\s*\d*\.?\d+(?:e[-+]?\d+)?)i(?:\s*\|\s*Z:\s*([\d.e+-]+))?(?:\s*\|\s*I:\s*(\d+))?/i,
        );
        if (match) {
          history.push({ ...state });
          state.r = parseFloat(match[1]);
          state.i = parseFloat(match[2].replace(/\s+/g, ""));
          if (match[3]) state.zoom = 3.0 / parseFloat(match[3]);
          if (match[4]) state.maxIter = parseInt(match[4]);
          render();
        }
      }

      canvas.onclick = (e) => {
        history.push({ ...state });
        const rect = canvas.getBoundingClientRect();
        state.r +=
          (e.clientX - rect.left - canvas.width / 2) *
          (state.zoom / canvas.width);
        state.i +=
          (e.clientY - rect.top - canvas.height / 2) *
          (state.zoom / canvas.width);
        state.zoom *= 0.2;
        state.maxIter = Math.floor(state.maxIter * 1.12);
        render();
      };

      function goBack() {
        if (history.length > 0) {
          state = history.pop();
          render();
        }
      }
      function resetView() {
        history.push({ ...state });
        state = { ...initialState };
        render();
      }
      function saveImage() {
        canvas.toBlob((b) => saveAs(b, `mandel_${coordInput.value}.png`));
      }
      render();
    </script>
  </body>
</html>
