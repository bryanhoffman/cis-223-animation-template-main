<!DOCTYPE html>
<html>
<head>
    <title>High-Precision Fractal Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; color: #e0e0e0; font-family: sans-serif; display: flex; height: 100vh; }
        #sidebar { width: 320px; background: #2d2d2d; padding: 20px; z-index: 10; border-right: 1px solid #444; }
        .input-group { margin-bottom: 12px; }
        label { display: block; font-size: 11px; color: #888; margin-bottom: 4px; }
        input, textarea { width: 100%; background: #111; border: 1px solid #444; color: #0f0; padding: 8px; box-sizing: border-box; font-family: monospace; }
        button { width: 100%; padding: 10px; margin-top: 8px; border: none; cursor: pointer; font-weight: bold; }
        #renderBtn { background: #3498db; color: white; }
        #viewer { flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #000; }
        canvas { max-width: 95%; max-height: 95%; background: #050505; }
        #status { color: #f1c40f; font-family: monospace; font-size: 12px; margin-top: 10px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Fractal Explorer</h2>
    <div class="input-group">
        <label>Coordinate (Real + Imaginary i)</label>
        <textarea id="coordInput" rows="3">-0.52303311455273 + 0.52633594081346i</textarea>
    </div>
    <div class="input-group">
        <label>Vertical Range (Zoom)</label>
        <input type="text" id="rangeInput" value="0.00000001">
    </div>
    <div class="input-group">
        <label>Max Iterations</label>
        <input type="number" id="iterInput" value="1000">
    </div>
    <button id="renderBtn">START RENDER</button>
    <button id="saveBtn" style="background:#27ae60; color:white;">SAVE PNG</button>
    <div id="status">Idle. Click Render to start.</div>
</div>

<div id="viewer">
    <canvas id="mainCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const PRECISION_BITS = 120n; 
const SCALE = 1n << PRECISION_BITS;

// Set internal resolution
canvas.width = 1280;
canvas.height = 720;

function hslToRgb(h, s, l) {
    s /= 100; l /= 100;
    const k = n => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, 9 - k(n), 1));
    return (255 << 24) | (Math.round(255 * f(4)) << 16) | (Math.round(255 * f(8)) << 8) | Math.round(255 * f(0));
}

function render() {
    const status = document.getElementById('status');
    status.innerText = "Calculating...";
    
    // Wrap in setTimeout to let the UI update the "Calculating" message
    setTimeout(() => {
        const coords = document.getElementById('coordInput').value.match(/[-+]?[0-9]*\.?[0-9]+/g);
        const x_off = parseFloat(coords[0]);
        const y_off = parseFloat(coords[1]);
        const range = parseFloat(document.getElementById('rangeInput').value);
        const max_iter = parseInt(document.getElementById('iterInput').value);
        const aspect = canvas.width / canvas.height;

        const imgData = ctx.createImageData(canvas.width, canvas.height);
        const data32 = new Uint32Array(imgData.data.buffer);

        const x_off_bi = BigInt(Math.floor(x_off * Number(SCALE)));
        const y_off_bi = BigInt(Math.floor(y_off * Number(SCALE)));
        const y_rng_bi = BigInt(Math.floor(range * Number(SCALE)));
        const x_rng_bi = BigInt(Math.floor((range * aspect) * Number(SCALE)));
        const escape_limit = 4n << PRECISION_BITS;

        // Build LUT
        const lut = new Uint32Array(max_iter + 1);
        for (let i = 0; i < max_iter; i++) {
            lut[i] = hslToRgb((i * 5) % 360, 100, 50);
        }
        lut[max_iter] = (255 << 24);

        const start = performance.now();

        // Check if we can use symmetry (only if y is centered at 0 and range covers it)
        const canMirror = Math.abs(y_off) < 1e-15;

        for (let j = 0; j < (canMirror ? canvas.height / 2 : canvas.height); j++) {
            const y_val = (y_rng_bi * BigInt(j) / BigInt(canvas.height) - y_rng_bi / 2n) + y_off_bi;
            
            for (let i = 0; i < canvas.width; i++) {
                const x_val = (x_rng_bi * BigInt(i) / BigInt(canvas.width) - x_rng_bi / 2n) + x_off_bi;
                
                let x_iter = x_val, y_iter = y_val, iteration = max_iter;
                for (let k = 0; k < max_iter; k++) {
                    const x2 = (x_iter * x_iter) >> PRECISION_BITS;
                    const y2 = (y_iter * y_iter) >> PRECISION_BITS;
                    if (x2 + y2 > escape_limit) { iteration = k; break; }
                    y_iter = ((x_iter * y_iter) >> (PRECISION_BITS - 1n)) + y_val;
                    x_iter = x2 - y2 + x_val;
                }

                const color = lut[iteration];
                data32[j * canvas.width + i] = color;
                if (canMirror) {
                    data32[(canvas.height - 1 - j) * canvas.width + i] = color;
                }
            }
        }

        ctx.putImageData(imgData, 0, 0);
        status.innerText = `Done: ${Math.round(performance.now() - start)}ms`;
    }, 50);
}

document.getElementById('renderBtn').addEventListener('click', render);
document.getElementById('saveBtn').addEventListener('click', () => {
    canvas.toBlob(blob => saveAs(blob, "fractal.png"));
});
</script>
</body>
</html>